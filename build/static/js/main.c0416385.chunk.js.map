{"version":3,"sources":["sortinalgorithms/sortingAlgorithms.js","sortinalgorithms/BubbleSort.js","sortinalgorithms/QuickSort.js","sortinalgorithms/selectionSort.js","SortingVisualizer/SortingVisualizer.jsx","sortinalgorithms/insertionSort.js","component/mergePage.js","component/QuickSort.js","component/SelectionSort.js","component/BubblePage.js","component/siderbardata.js","component/sidebar.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","i","j","push","doMerge","getBubblesSortAnimations","animation","swap","bubbleSort","before","after","temp","getQuickSortAnimation","auxillaryArray","quickSort","startIndex","endIndex","pivotIndex","pivot","partitionArray","firstIndex","secondIndex","getSelectionSortAnimation","minIndex","selectionSort","SortingVisualizer","props","state","terminate","number_bar","animation_speed","this","resetArray","randomIntGeneration","setState","console","log","document","getElementById","disabled","disableWhenRunning","arrayBar","getElementsByClassName","isColorChange","setTimeout","enableafterRunning","barOneIndex","barTwoIndex","barOneStyle","style","barTwoStyle","color","backgroundColor","newHeight","height","arrayBars","barIndex","barStyle","value","hole","insertionSort","getInsertionSortAnimation","jsSortingBuiltIn","sort","a","b","checkArrayEqual","className","Button","id","onClick","mergeSortImpl","quickSortImpl","bubbleSortImpl","insertionSortImpl","selectionSortImpl","map","idx","key","React","Component","min","max","random","arr1","arr2","MergeSort","class","href","width","src","title","frameBorder","allow","allowFullScreen","QuickSort","SelectionSort","BubbleSort","SidebarData","path","icon","cName","Navbar","useState","sidebar","Provider","to","item","index","App","exact","element","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c0416385.chunk.js","sourcesContent":["export function getMergeSortAnimations(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  const auxiliaryArray = array.slice();\r\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n  return animations;\r\n}\r\n\r\nexport function getBubbleSortAnimation(arr) {\r\n  const animations = [];\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (arr.length - i - 1 == 0) {\r\n      animations.push([4, 0]);\r\n    }\r\n    for (var j = 0; j < arr.length - i - 1; j++) {\r\n      animations.push([1, [j, j + 1]]);\r\n      if (arr[j] > arr[j + 1]) {\r\n        var temp = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = temp;\r\n      }\r\n      animations.push([3, [j, arr[j]]]);\r\n      animations.push([3, [j + 1, arr[j + 1]]]);\r\n      animations.push([2, [j, j + 1]]);\r\n      if (j + 1 == arr.length - i - 1) {\r\n        animations.push([4, j + 1]);\r\n      }\r\n    }\r\n  }\r\n  return animations;\r\n}\r\nexport function getInsertionSortAnimation(inputArr) {\r\n  const animations = [];\r\n  let n = inputArr.length;\r\n  for (let i = 1; i < n; i++) {\r\n    // Choosing the first element in our unsorted subarray\r\n    let current = inputArr[i];\r\n    // The last element of our sorted subarray\r\n    let j = i - 1;\r\n    animations.push([2, [i, j]]);\r\n    while (j > -1 && current < inputArr[j]) {\r\n      inputArr[j + 1] = inputArr[j];\r\n      animations.push([1, [i, j]]);\r\n      animations.push([3, [j + 1, inputArr[j + 1]]]);\r\n      animations.push([2, [i, j]]);\r\n\r\n      j--;\r\n    }\r\n\r\n    inputArr[j + 1] = current;\r\n    if (i == n - 1) animations.push([4, i]);\r\n    animations.push([3, [j + 1, inputArr[j + 1]]]);\r\n  }\r\n  return animations;\r\n}\r\nexport function getSelectionSortAnimation(inputArr) {\r\n  const animations = [];\r\n  let n = inputArr.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    // Finding the smallest number in the subarray\r\n    let min = i;\r\n    for (let j = i + 1; j < n; j++) {\r\n      animations.push([1, [min, j]]);\r\n      animations.push([2, [min, j]]);\r\n      if (inputArr[j] < inputArr[min]) {\r\n        animations.push([3, min]);\r\n        min = j;\r\n        animations.push([4, min]);\r\n      }\r\n    }\r\n    if (min != i) {\r\n      // Swapping the elements\r\n      let tmp = inputArr[i];\r\n      inputArr[i] = inputArr[min];\r\n      inputArr[min] = tmp;\r\n    }\r\n    animations.push([5, [min, inputArr[min]]]);\r\n    animations.push([5, [i, inputArr[i]]]);\r\n    animations.push([3, min]);\r\n    animations.push([6, i]);\r\n  }\r\n  return animations;\r\n}\r\n\r\nexport function getQuickSortAnimation(arr, start, end, animations) {\r\n  if (start >= end) {\r\n    return;\r\n  }\r\n\r\n  // Returns pivotIndex\r\n  let index = partition(arr, start, end, animations);\r\n\r\n  // Recursively apply the same logic to the left and right subarrays\r\n  getQuickSortAnimation(arr, start, index - 1, animations);\r\n  getQuickSortAnimation(arr, index + 1, end, animations);\r\n  return animations;\r\n}\r\n\r\nfunction partition(arr, start, end, animations) {\r\n  // Taking the last element as the pivot\r\n  const pivotValue = arr[end];\r\n  animations.push([-4, [1, end]]);\r\n  let pivotIndex = start;\r\n  for (let i = start; i < end; i++) {\r\n    animations.push([-1, [i, end]]);\r\n    animations.push([-1, [pivotIndex, end]]);\r\n    animations.push([-2, [i, end]]);\r\n    animations.push([-2, [pivotIndex, end]]);\r\n    if (arr[i] < pivotValue) {\r\n      // Swapping elements\r\n      [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];\r\n      // Moving to next element\r\n      animations.push([-3, [i, arr[i]]]);\r\n      animations.push([-3, [pivotIndex, arr[pivotIndex]]]);\r\n      pivotIndex++;\r\n    }\r\n  }\r\n  animations.push([-5, [1, end]]);\r\n\r\n  // Putting the pivot value in the middle\r\n  [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]];\r\n  animations.push([-3, [pivotIndex, arr[pivotIndex]]]);\r\n  animations.push([-3, [end, arr[end]]]);\r\n  return pivotIndex;\r\n}\r\n\r\nfunction mergeSortHelper(\r\n  mainArray,\r\n  startIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations\r\n) {\r\n  if (startIdx === endIdx) return;\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(\r\n  mainArray,\r\n  startIdx,\r\n  middleIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations\r\n) {\r\n  let k = startIdx;\r\n  let i = startIdx;\r\n  let j = middleIdx + 1;\r\n  while (i <= middleIdx && j <= endIdx) {\r\n    animations.push([i, j]);\r\n    animations.push([i, j]);\r\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    } else {\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n  while (i <= middleIdx) {\r\n    animations.push([i, i]);\r\n    animations.push([i, i]);\r\n    animations.push([k, auxiliaryArray[i]]);\r\n    mainArray[k++] = auxiliaryArray[i++];\r\n  }\r\n  while (j <= endIdx) {\r\n    animations.push([j, j]);\r\n    animations.push([j, j]);\r\n    animations.push([k, auxiliaryArray[j]]);\r\n    mainArray[k++] = auxiliaryArray[j++];\r\n  }\r\n}\r\n","//Function to handle bubble sort:\r\nexport function getBubblesSortAnimations(array) {\r\n    //variable to hold the animation list of the array\r\n    const animation = [];\r\n    //make a copy of each element into another array\r\n    const auxiliaryArray = array.slice();\r\n    //sort the array through bubble sort\r\n    bubbleSort(animation, auxiliaryArray);\r\n    return animation;\r\n  }//end of bubble sort\r\n\r\n//Function to sort the array using bubble sort\r\nfunction bubbleSort(animation, array)\r\n{\r\n    \r\n    //looping through the array and chek if each element is on the right order or not\r\n    for(let i = 0; i < array.length - 1; i++)\r\n    {\r\n        for(let j = 0; j < array.length - i - 1; j++)\r\n        {\r\n            animation.push([j, j+1]);\r\n            animation.push([j, j+1]);\r\n            if(array[j] > array[j+1])\r\n            {\r\n                animation.push([j, array[j+1]]);\r\n                animation.push([j + 1, array[j]]);\r\n                //swap the elment if they are not in the right order\r\n                swap(j, j+1, array);\r\n\r\n            }\r\n\r\n            else{\r\n                //the array is already sorted\r\n                animation.push([-1,-1]);\r\n                animation.push([-1,-1]);\r\n            }\r\n        }\r\n    }\r\n}//end of bubbleSort(animation, array)\r\n  \r\n\r\n//Helper method to swap the elemenet: \r\nfunction swap(before, after, array)\r\n{\r\n    \r\n    //swap the element:\r\n    let temp = array[before]; \r\n    array[before] = array[after];\r\n    array[after] = temp;\r\n}//end of swap()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   ","//function to handle quicks sort animation on the front end\r\nexport function getQuickSortAnimation(array) {\r\n    let animations  = [];\r\n    let auxillaryArray = array.slice();\r\n    quickSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\r\n    return animations;\r\n}//end of getQuickSortAnimation()\r\n\r\n\r\n//function to handle the quickSort algorithm:\r\nfunction quickSort(auxillaryArray, startIndex, endIndex, animations) {\r\n    let pivotIndex; //the index of the pivot element in the array\r\n    //checking the upper and lower bound of the array\r\n    if (startIndex < endIndex) {\r\n        //return the index of pivot element in the array\r\n        pivotIndex = partitionArray(auxillaryArray, startIndex, endIndex, animations);\r\n        //recursive call to sort the left and right partition of the array\r\n        quickSort(auxillaryArray, startIndex, pivotIndex - 1, animations);\r\n        quickSort(auxillaryArray, pivotIndex + 1, endIndex, animations);\r\n    }\r\n}//end of quick sort()\r\n\r\n//Helper method to partition the the array into left and right elements\r\nfunction partitionArray(auxillaryArray, startIndex, endIndex, animations) {\r\n    let pivot = auxillaryArray[endIndex];\r\n    let pivotIndex = startIndex;\r\n    for (let i = startIndex; i <= endIndex - 1; i++) {\r\n        animations.push([i, endIndex]);\r\n        animations.push([i, endIndex]);\r\n        if (auxillaryArray[i] <= pivot) {\r\n            //Swap these two heights\r\n            animations.push([i, auxillaryArray[pivotIndex]]);\r\n            animations.push([pivotIndex, auxillaryArray[i]]);\r\n            swap(auxillaryArray, i , pivotIndex);\r\n            pivotIndex++;\r\n        }\r\n        else {\r\n            animations.push([-1, -1]);\r\n            animations.push([-1, -1]);\r\n        }\r\n        animations.push([-1, -1]);\r\n        animations.push([-1, -1]);\r\n    }\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    //Swap these two heights\r\n    animations.push([pivotIndex, auxillaryArray[endIndex]]);\r\n    animations.push([endIndex, auxillaryArray[pivotIndex]]);\r\n    swap(auxillaryArray, pivotIndex, endIndex);\r\n    return pivotIndex;\r\n}//end of partiontArray()\r\n\r\n//helper method to swap between two different element in the array\r\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\r\n    let temp = auxillaryArray[firstIndex];\r\n    auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\r\n    auxillaryArray[secondIndex] = temp;\r\n}//end of swap()\r\n\r\n","export function getSelectionSortAnimation(array) {\r\n    let animations  = [];\r\n    let auxillaryArray = array.slice();\r\n    selectionSort(auxillaryArray, animations);\r\n    return animations;\r\n}\r\n//function to handle the selection sort algorithm\r\nfunction selectionSort(auxillaryArray, animations) {\r\n    const length = auxillaryArray.length;\r\n    for (let i = 0; i < length - 1; i++) {\r\n        let minIndex = i; //Finding minimum element in unsorted array\r\n        for (let j = i + 1; j < length; j++) {\r\n            animations.push([\"comparision1\", j, minIndex]);\r\n            animations.push([\"comparision2\", j, minIndex]);\r\n            if (auxillaryArray[j] < auxillaryArray[minIndex]) {\r\n                minIndex = j;\r\n            }\r\n        }\r\n        animations.push([\"swap\", minIndex, auxillaryArray[i]]);\r\n        animations.push([\"swap\", i, auxillaryArray[minIndex]]);\r\n        // Swap the found minimum element with the first element\r\n        swap(auxillaryArray, minIndex, i);\r\n    }\r\n}\r\n\r\n//helper method to swap element within an array\r\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\r\n    let temp = auxillaryArray[firstIndex];\r\n    auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\r\n    auxillaryArray[secondIndex] = temp;\r\n}\r\n","//import external dependencies:\r\nimport React from 'react';\r\nimport {getMergeSortAnimations} from '../sortinalgorithms/sortingAlgorithms.js'\r\nimport {getBubblesSortAnimations} from '../sortinalgorithms/BubbleSort.js'\r\nimport {getQuickSortAnimation} from '../sortinalgorithms/QuickSort.js'\r\nimport {getInsertionSortAnimation} from '../sortinalgorithms/insertionSort.js'\r\nimport {getSelectionSortAnimation} from '../sortinalgorithms/selectionSort.js'\r\nimport './SortingVisualizer.css';\r\nimport { Button, Row, Col } from \"react-bootstrap\";\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n//global variable to control the speed of the animation\r\n//for MERGE sort\r\nconst ANIMATION_SPEED_MS = 0.5;\r\n//number of array bars being displayed\r\nconst NUMBER_OF_ARRAY_BARS = 240; \r\n//main color of the array bars:\r\nconst PRIMARY_COLOR = 'turquoise';\r\n//the color of the array bar that is being compared throughout the sort\r\nconst SECONDARY_COLOR = 'red';\r\n\r\n//the main function of the react app\r\nexport default class SortingVisualizer extends React.Component {\r\n    //sorting constructor:\r\n    constructor(props) {\r\n      super(props);\r\n  \r\n      this.state = {\r\n        terminate: false,\r\n        number_bar : NUMBER_OF_ARRAY_BARS,\r\n        animation_speed : ANIMATION_SPEED_MS,\r\n        array: [],  //main array that would print out the element to be sorted.\r\n      };\r\n    }\r\n    \r\n    //when the component of the app is loaded, it will reset the current of element\r\n    componentDidMount() {\r\n      this.resetArray();\r\n    }\r\n\r\n    //resetting the array and generate new elements each time\r\n    resetArray(){\r\n        const array = [];\r\n        //generating random integer for sorting: \r\n        for(let i = 0; i <=  NUMBER_OF_ARRAY_BARS; i++)\r\n        {\r\n            //pushing the integer into the array: \r\n            array.push(randomIntGeneration(5, 670));\r\n        }\r\n        this.setState({array});\r\n    }\r\n    disableWhenRunning(){\r\n      console.log(\"yyeyyyyyes\")\r\n      document.getElementById(\"button1\").disabled = true\r\n      document.getElementById(\"button2\").disabled = true\r\n      document.getElementById(\"button3\").disabled = true\r\n      document.getElementById(\"button4\").disabled = true\r\n      document.getElementById(\"button5\").disabled = true\r\n      document.getElementById(\"button6\").disabled = true\r\n    }\r\n    enableafterRunning(i){\r\n            document.getElementById(\"button1\").disabled = false\r\n            document.getElementById(\"button2\").disabled = false\r\n            document.getElementById(\"button3\").disabled = false\r\n            document.getElementById(\"button4\").disabled = false\r\n            document.getElementById(\"button5\").disabled = false\r\n            document.getElementById(\"button6\").disabled = false\r\n          \r\n      }\r\n\r\n    //sorting alorithms:\r\n    mergeSortImpl()\r\n    {\r\n      this.disableWhenRunning()\r\n      //variable to intialize the animation for the current given array\r\n      const animation = getMergeSortAnimations(this.state.array);\r\n      for(let i = 0; i < animation.length; i++)\r\n      {\r\n        const arrayBar = document.getElementsByClassName('array-bar');\r\n        const isColorChange = i % 3 !== 2; //NEED TO RESEARCH MORE ABOUT THIS\r\n        \r\n        if (i == animation.length - 1) {\r\n          console.log(\"possible\")\r\n          setTimeout(() => \r\n          {\r\n            this.enableafterRunning(i)\r\n          },i*this.state.animation_speed)\r\n        }\r\n       \r\n        if(isColorChange)\r\n        {\r\n          const [barOneIndex, barTwoIndex] = animation[i];\r\n          const barOneStyle = arrayBar[barOneIndex].style;\r\n          const barTwoStyle = arrayBar[barTwoIndex].style;\r\n          const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n          setTimeout(() => {\r\n            barOneStyle.backgroundColor = color;\r\n            barTwoStyle.backgroundColor = color;\r\n          }, i * this.state.animation_speed);\r\n        } \r\n        else{\r\n          setTimeout(() => {\r\n            const [barOneIndex, newHeight] = animation[i];\r\n            const barOneStyle = arrayBar[barOneIndex].style;\r\n            barOneStyle.height = `${newHeight}px`;\r\n          }, i * this.state.animation_speed);\r\n        }\r\n      }\r\n    \r\n    } //end of mergeSortImpl\r\n    \r\n    //Quick sort implementation:\r\n    quickSortImpl() {\r\n      this.disableWhenRunning()\r\n      const animations = getQuickSortAnimation(this.state.array);\r\n      for (let i = 0; i < animations.length - 1; i++) {\r\n          const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n          const isColorChange = (i % 6 === 0) || (i % 6 === 1);\r\n          \r\n          if (i == animations.length - 3) {\r\n            console.log(\"possible\")\r\n            setTimeout(() => \r\n            {\r\n              \r\n              this.enableafterRunning(i)\r\n            },i*this.state.animation_speed)\r\n          }\r\n          if(isColorChange === true) {\r\n              const color = (i % 6 === 0) ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n              const [barOneIndex, barTwoIndex] = animations[i];\r\n              if(barOneIndex === -1) {\r\n                  continue;\r\n              }\r\n              const barOneStyle = arrayBars[barOneIndex].style;\r\n              const barTwoStyle = arrayBars[barTwoIndex].style;\r\n              setTimeout(() => {\r\n                  barOneStyle.backgroundColor = color;\r\n                  barTwoStyle.backgroundColor = color;\r\n              },i * this.state.animation_speed);\r\n          }\r\n          else {\r\n              const [barIndex, newHeight] = animations[i];\r\n              if (barIndex === -1) {\r\n                  continue;\r\n              }\r\n              const barStyle = arrayBars[barIndex].style;\r\n              setTimeout(() => {\r\n                  barStyle.height = `${newHeight}px`;\r\n              },i * this.state.animation_speed);  \r\n          }\r\n      }\r\n  }//end of quickSortImpl()\r\n\r\n  //Heap sort implementation:\r\n  heapSortImpl()\r\n  {\r\n\r\n  }//end of heapSortImpl()\r\n\r\n  //Insertion sort JS implementation:\r\n  insertionSortImpl()\r\n  {\r\n    this.disableWhenRunning()\r\n    const animation = getInsertionSortAnimation(this.state.array);\r\n    //looping though the animation array: \r\n    for(let i = 0; i < animation.length; i++)\r\n    {\r\n      if (i == animation.length - 2) {\r\n        console.log(\"possible\")\r\n        setTimeout(() => \r\n        {\r\n          this.enableafterRunning(i)\r\n        },i*this.state.animation_speed)\r\n      }\r\n      const isColorChange = (animation[i][0] === \"comparison1\" || (animation[i][0] === \"comparison2\"));\r\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n      if(isColorChange)\r\n      {\r\n        const color = (animation[i][0] === \"comparison1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n        const[temp, barOneIndex, barTwoIndex] = animation[i];\r\n        const barOneStyle = arrayBars[barOneIndex].style;\r\n        const barTwoStyle = arrayBars[barTwoIndex].style;\r\n        setTimeout(() => {\r\n          barOneStyle.backgroundColor = color;\r\n          barTwoStyle.backgroundColor = color;\r\n        }, i * this.state.animation_speed);\r\n      }\r\n      else{\r\n        const[temp, barIndex, newHeight] = animation[i];\r\n        const barStyle = arrayBars[barIndex].style;\r\n        setTimeout(() => {\r\n          barStyle.height = `${newHeight}px`;\r\n        }, i * this.state.animation_speed);\r\n      }\r\n    }\r\n\r\n  }//end of insertionSortImpl()\r\n\r\n  selectionSortImpl() {\r\n    this.disableWhenRunning()\r\n    const animations = getSelectionSortAnimation(this.state.array);\r\n    //loop through the animation array to determine the changes of the color\r\n    for (let i = 0; i < animations.length; i++) {\r\n      if (i == animations.length - 1) {\r\n        console.log(\"possible\")\r\n        setTimeout(() => \r\n        {\r\n          \r\n          this.enableafterRunning(i)\r\n        },i*this.state.animation_speed)\r\n      }\r\n        const isColorChange = (animations[i][0] === \"comparision1\") || (animations[i][0] === \"comparision2\");\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n        if(isColorChange === true) {\r\n            const color = (animations[i][0] === \"comparision1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n            const [temp, barOneIndex, barTwoIndex] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIndex].style;\r\n            const barTwoStyle = arrayBars[barTwoIndex].style;\r\n            setTimeout(() => {\r\n                barOneStyle.backgroundColor = color;\r\n                barTwoStyle.backgroundColor = color;\r\n            },i * this.state.animation_speed);\r\n        }\r\n        else {\r\n            const [temp, barIndex, newHeight] = animations[i];\r\n            const barStyle = arrayBars[barIndex].style;\r\n            setTimeout(() => {\r\n                barStyle.height = `${newHeight}px`;\r\n            },i * this.state.animation_speed);  \r\n        }\r\n    }\r\n  }//end of selection sort\r\n    \r\n    //bubble sort:\r\n    bubbleSortImpl()\r\n    {\r\n      this.disableWhenRunning();\r\n      //variable to hold the animation return value from the bubble sort function\r\n      const animation = getBubblesSortAnimations(this.state.array);\r\n      for(let i = 0; i < animation.length; i++)\r\n      {\r\n        //extract the bar from the HTML side\r\n        const arrayBar = document.getElementsByClassName('array-bar');\r\n        const isColorChange = (i % 4 === 0) || (i % 4 === 1);\r\n        //if the color changed:\r\n        if(isColorChange)\r\n        {\r\n          const [barOneIndex, barTwoIndex] = animation[i];\r\n          const barOneStyle = arrayBar[barOneIndex].style;\r\n          const barTwoStyle = arrayBar[barTwoIndex].style;\r\n          const color = i % 4 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n          setTimeout(() =>\r\n            {\r\n              barOneStyle.backgroundColor = color;\r\n              barTwoStyle.backgroundColor = color;\r\n\r\n            }, i * this.state.animation_speed);\r\n          if(i == animation.length - 1){\r\n            this.enableafterRunning(i)\r\n          }\r\n        }\r\n        //if the color has not changed:\r\n        else\r\n        {\r\n          const [barOneIndex, newHeight] = animation[i];\r\n          if (barOneIndex === -1)\r\n          {\r\n            continue;\r\n          }\r\n          const barStyle = arrayBar[barOneIndex].style;\r\n          setTimeout(() => {\r\n            barStyle.height = `${newHeight}px`;\r\n          }, i * this.state.animation_speed);\r\n        }\r\n\r\n      }\r\n\r\n    }//end of bubble sort implementation\r\n\r\n    //function to test all sorting algorithm for debugging\r\n    testSortingAlgorithms()\r\n    {\r\n      //the function will create 100 array with different length\r\n      for(var i = 0; i < 100; i++)\r\n      {\r\n        // create an array at each iteration: \r\n        const array = []\r\n        //each array will have various length from 1 to 1000 \r\n        for(var j = 0; j < randomIntGeneration(1, 1000); j++)\r\n        {\r\n          //the array will push element into it until the for loop is exhausted. \r\n          array.push(randomIntGeneration(0, 1000));\r\n        }//end for loop.\r\n\r\n        //testing the sorting algorithm: \r\n        const jsSortingBuiltIn = array.slice().sort((a,b) => a - b); //java built-in sorting function\r\n        const selectionSort = getSelectionSortAnimation(array.slice());\r\n        \r\n\r\n        console.log(checkArrayEqual(jsSortingBuiltIn, selectionSort));\r\n        \r\n      }\r\n    }\r\n\r\n    render()\r\n    {\r\n        const {array} = this.state;\r\n\r\n        return (\r\n\r\n          <div className=\"array-container\">\r\n            <h>Visualize Soring algorithm</h>\r\n            <div className='button'>\r\n            <Button id=\"button1\" onClick={() => this.resetArray()}>Generate New Array</Button>\r\n            <Button id=\"button2\" onClick={() => this.mergeSortImpl()}>Merge Sort</Button>\r\n            <Button id=\"button3\" onClick={() => this.quickSortImpl()}>Quick Sort</Button>\r\n            {/* <button onClick={() => this.heapSortImpl()}>Heap Sort</button> */}\r\n            <Button id=\"button4\" onClick={() => this.bubbleSortImpl()}>Bubble Sort</Button>\r\n            <Button id=\"button5\" onClick={() => this.insertionSortImpl()}>Insertion Sort</Button>\r\n            <Button id=\"button6\" onClick={() => this.selectionSortImpl()}>Selection Sort</Button>\r\n            {/* <Button id=\"button7\" onClick={()=>{this.setState({terminate:true})}}>terminate</Button> */}\r\n          </div>\r\n      \r\n          {array.map((value, idx) => (\r\n            <div className=\"array-bar\" key={idx}\r\n              style={{\r\n                backgroundColor: PRIMARY_COLOR,\r\n                height: `${value}px`,\r\n              }}> </div>\r\n          ))}\r\n        </div>\r\n            \r\n        );\r\n\r\n    }\r\n\r\n}\r\n\r\n//Function to generate random integer from 5 to 1000\r\nfunction randomIntGeneration(min, max) \r\n{\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n//Function to test if two array of elements equal to each other\r\nfunction checkArrayEqual(arr1, arr2)\r\n{\r\n  //if the two arrays are not equal to each other in length, then they are not equal.\r\n  if (arr1.length !== arr2.length)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  // looping through each character and check if they are both equals\r\n  for (let i=0; i < arr1.length; i++)\r\n  {\r\n    if (arr1[i] !== arr2[i])\r\n    {\r\n      //array are equals\r\n      return false;\r\n      \r\n    }\r\n\r\n  }\r\n  return true;\r\n} //end of program\r\n","//The entire insertion sort implementation of this project\r\nexport function getInsertionSortAnimation(array){\r\n    //animation array:\r\n    let animation = [];\r\n    let auxilaryArray = array.slice();\r\n    //implemnent insertion sort and animation\r\n    insertionSort(auxilaryArray, animation);\r\n    return animation;\r\n}//end of getInsertionSortAlgorithm()\r\n\r\n\r\nfunction insertionSort(array, animation)\r\n{\r\n    //looping through the array starting from index 1 because index 0 is assumed to be the sorted part of the array:\r\n    for(let i = 1; i < array.length; i++)\r\n    {\r\n        let value = array[i];\r\n        let hole = i - 1;\r\n        //changing the color of the elements:\r\n        animation.push([\"comparison1\", hole, i]);\r\n        animation.push([\"comparison2\", hole, i]);\r\n        //the index is not in 0 and the previous is greater than the current value:\r\n        while(hole >= 0 && array[hole] > value)\r\n        {\r\n            animation.push(['overwrite', hole + 1, array[hole]]);\r\n            //swap the elements\r\n            array[hole+1] = array[hole]; \r\n            hole--; \r\n            if(hole >=0){\r\n                animation.push([\"comparison1\", hole, i]);\r\n                animation.push([\"comparison2\", hole, i]);\r\n            }\r\n        }\r\n\r\n        animation.push([\"overwrite\", hole + 1, value]);\r\n        array[hole + 1] = value;\r\n    }\r\n\r\n}","import React from \"react\";\r\nimport \"./sortPage.css\"\r\n\r\nfunction MergeSort() {\r\n  return (\r\n    <><div class = \"container\">\r\n      <div className=\"title\">Merge Sort &Theta;(nlogn)</div>\r\n      <hr></hr>\r\n      <div className=\"para\">\r\n        Merge sort is a divide and conquer algorithm that was invented by John\r\n        von Neumann in 1945.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">Conceptually, a merge sort works as follows: </div>\r\n      <div className=\"para\">\r\n        1. Divide the unsorted list into n sublists, each containing one element\r\n        (a list of one element is considered sorted).\r\n      </div>\r\n      <div className=\"para\">\r\n        2. Repeatedly merge sublists to produce new sorted sublists until there\r\n        is only one sublist remaining. This will be the sorted list.{\" \"}\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">Pseudo-code:</div>\r\n      <pre className=\"code\">\r\n        {`\r\n        function merge(left, right)\r\n        var result := empty list\r\n    \r\n        while left is not empty and right is not empty do\r\n            if first(left) â‰¤ first(right) then\r\n                append first(left) to result\r\n                left := rest(left)\r\n            else\r\n                append first(right) to result\r\n                right := rest(right)\r\n    \r\n        // Either left or right may have elements left; consume them.\r\n        // (Only one of the following loops will actually be entered.)\r\n        while left is not empty do\r\n            append first(left) to result\r\n            left := rest(left)\r\n        while right is not empty do\r\n            append first(right) to result\r\n            right := rest(right)\r\n        return result\r\n          `}\r\n      </pre>\r\n      <div className=\"para\">\r\n        For more information, please refer to\r\n        <a href=\"https://en.wikipedia.org/wiki/Merge_sort\"> Wikipedia.</a>\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"cc\">\r\n        <iframe\r\n          width=\"560\"\r\n          height=\"315\"\r\n          src=\"https://www.youtube.com/embed/4VqmGXwpLqc\"\r\n          title=\"YouTube video player\"\r\n          frameBorder=\"0\"\r\n          allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen\"\r\n          allowFullScreen\r\n        ></iframe>\r\n      </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default MergeSort;\r\n","import React from \"react\";\r\nimport \"./sortPage.css\"\r\n\r\n// react-bootstrap components\r\nimport {\r\n  Badge,\r\n  Button,\r\n  Card,\r\n  Navbar,\r\n  Nav,\r\n  Container,\r\n  Row,\r\n  Col,\r\n} from \"react-bootstrap\";\r\n\r\nfunction QuickSort() {\r\n  return (\r\n    <>\r\n    <div class = \"container\">\r\n      <div className=\"title\">Quick Sort &Theta;(nlogn)&#8612;(Average)</div>\r\n      <hr></hr>\r\n      <div className=\"para\">\r\n        Quicksort is a divide-and-conquer algorithm. It works by selecting a\r\n        'pivot' element from the array and partitioning the other elements into\r\n        two sub-arrays, according to whether they are less than or greater than\r\n        the pivot.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">\r\n        For this reason, it is sometimes called partition-exchange sort. The\r\n        sub-arrays are then sorted recursively. This can be done in-place,\r\n        requiring small additional amounts of memory to perform the sorting.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">Pseudo-code:</div>\r\n      <pre className=\"code\">\r\n        {`\r\n        algorithm quicksort(A, lo, hi) is\r\n        if lo < hi then\r\n            p := partition(A, lo, hi)\r\n            quicksort(A, lo, p - 1)\r\n            quicksort(A, p + 1, hi)\r\n\r\n        algorithm partition(A, lo, hi) is\r\n        pivot := A[hi]\r\n        i := lo\r\n        for j := lo to hi do\r\n            if A[j] < pivot then\r\n                swap A[i] with A[j]\r\n                i := i + 1\r\n        swap A[i] with A[hi]\r\n        return i\r\n        `}\r\n      </pre>\r\n      <div className=\"para\">\r\n        For more information, please refer to\r\n        <a href=\"https://en.wikipedia.org/wiki/Quicksort\"> Wikipedia.</a>\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"cc\">\r\n        <iframe\r\n          width=\"560\"\r\n          height=\"315\"\r\n          src=\"https://www.youtube.com/embed/Hoixgm4-P4M\"\r\n          title=\"YouTube video player\"\r\n          frameBorder=\"0\"\r\n          allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen\"\r\n          allowFullScreen\r\n        ></iframe>\r\n      </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default QuickSort;\r\n","import React from \"react\";\r\nimport \"./sortPage.css\"\r\n\r\n// react-bootstrap components\r\nimport {\r\n  Badge,\r\n  Button,\r\n  Card,\r\n  Navbar,\r\n  Nav,\r\n  Container,\r\n  Row,\r\n  Col,\r\n} from \"react-bootstrap\";\r\n\r\nfunction SelectionSort() {\r\n  return (\r\n    <><div className=\"container\">\r\n      <div className=\"title\">\r\n        Selection Sort &Theta;(n<sup>2</sup>)\r\n      </div>\r\n      <hr></hr>\r\n      <div className=\"para\">\r\n        Selection sort is an in-place comparison sorting algorithm.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">\r\n        The algorithm divides the input list into two parts: a sorted sublist of\r\n        items which is built up from left to right at the front (left) of the\r\n        list and a sublist of the remaining unsorted items that occupy the rest\r\n        of the list.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">\r\n        Initially, the sorted sublist is empty and the unsorted sublist is the\r\n        entire input list. The algorithm proceeds by finding the smallest (or\r\n        largest, depending on sorting order) element in the unsorted sublist,\r\n        exchanging (swapping) it with the leftmost unsorted element (putting it\r\n        in sorted order), and moving the sublist boundaries one element to the\r\n        right.\r\n      </div>\r\n\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\"> Implementation in C:</div>\r\n      <pre className=\"code\">\r\n        {`\r\n        /* a[0] to a[aLength-1] is the array to sort */\r\n        int i,j;\r\n        int aLength; // initialise to a's length\r\n\r\n        /* advance the position through the entire array */\r\n        /*   (could do i < aLength-1 because single element is also min element) */\r\n        for (i = 0; i < aLength-1; i++)\r\n        {\r\n            /* find the min element in the unsorted a[i .. aLength-1] */\r\n\r\n            /* assume the min is the first element */\r\n            int jMin = i;\r\n            /* test against elements after i to find the smallest */\r\n            for (j = i+1; j < aLength; j++)\r\n            {\r\n                /* if this element is less, then it is the new minimum */\r\n                if (a[j] < a[jMin])\r\n                {\r\n                    /* found new minimum; remember its index */\r\n                    jMin = j;\r\n                }\r\n            }\r\n\r\n            if (jMin != i) \r\n            {\r\n                swap(a[i], a[jMin]);\r\n            }\r\n        }\r\n      `}\r\n      </pre>\r\n      <div className=\"para\">\r\n        For more information, please refer to\r\n        <a href=\"https://en.wikipedia.org/wiki/Selection_sort\"> Wikipedia.</a>\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"cc\">\r\n        <iframe\r\n          width=\"560\"\r\n          height=\"315\"\r\n          src=\"https://www.youtube.com/embed/g-PGLbMth_g\"\r\n          title=\"YouTube video player\"\r\n          frameBorder=\"0\"\r\n          allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen\"\r\n          allowFullScreen\r\n        ></iframe>\r\n      </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default SelectionSort;\r\n","import React from \"react\";\r\nimport \"./sortPage.css\"\r\n// react-bootstrap components\r\nimport {\r\n  Badge,\r\n  Button,\r\n  Card,\r\n  Navbar,\r\n  Nav,\r\n  Table,\r\n  Container,\r\n  Row,\r\n  Col,\r\n} from \"react-bootstrap\";\r\n\r\nfunction BubbleSort() {\r\n  return (\r\n    <><div class = \"container\">\r\n      <div className=\"title\">\r\n        Bubble Sort &Theta;(n<sup>2</sup>)\r\n      </div>\r\n      <hr></hr>\r\n      <div className=\"para\">\r\n        Bubble sort, sometimes referred to as sinking sort, is a simple sorting\r\n        algorithm that repeatedly steps through the list, compares adjacent\r\n        elements and swaps them if they are in the wrong order.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">\r\n        The pass through the list is repeated until the list is sorted. The\r\n        algorithm, which is a comparison sort, is named for the way smaller or\r\n        larger elements \"bubble\" to the top of the list.\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">Pseudo-code:</div>\r\n      <pre className=\"code\">\r\n        {`\r\n        procedure bubbleSort(A : list of sortable items)\r\n        n := length(A)\r\n        repeat\r\n            swapped := false\r\n            for i := 1 to n - 1 inclusive do\r\n                if A[i - 1] > A[i] then\r\n                    swap(A[i - 1], A[i])\r\n                    swapped = true\r\n                end if\r\n            end for\r\n            n := n - 1\r\n        until not swapped\r\n        end procedure\r\n          `}\r\n      </pre>\r\n      <div className=\"para\">\r\n        For more information, please refer to\r\n        <a href=\"https://en.wikipedia.org/wiki/Bubble_sort\"> Wikipedia.</a>\r\n      </div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"para\">&nbsp;</div>\r\n      <div className=\"cc\">\r\n        <iframe\r\n          width=\"560\"\r\n          height=\"315\"\r\n          src=\"https://www.youtube.com/embed/xli_FI7CuzA\"\r\n          title=\"YouTube video player\"\r\n          frameBorder=\"0\"\r\n          allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen\"\r\n          allowFullScreen\r\n        ></iframe>\r\n      </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default BubbleSort;\r\n","import React from 'react';\r\nimport * as FaIcons from 'react-icons/fa';\r\nimport * as AiIcons from 'react-icons/ai';\r\nimport * as IoIcons from 'react-icons/io';\r\n\r\nexport const SidebarData = [\r\n  {\r\n    title: 'Home',\r\n    path: '/',\r\n    icon: <AiIcons.AiFillHome />,\r\n    cName: 'nav-text'\r\n  },\r\n  {\r\n    title: 'BubbleSort',\r\n    path: '/BubbleSort',\r\n    icon: <IoIcons.IoIosPaper />,\r\n    cName: 'nav-text'\r\n  },\r\n  {\r\n    title: 'MergeSort',\r\n    path: '/MergeSort',\r\n    icon: <IoIcons.IoIosPaper />,\r\n    cName: 'nav-text'\r\n  },\r\n  {\r\n    title: 'QuickSort',\r\n    path: '/QuickSort',\r\n    icon: <IoIcons.IoIosPaper />,\r\n    cName: 'nav-text'\r\n  },\r\n  {\r\n    title: 'SelectSort',\r\n    path: '/SelectSort',\r\n    icon: <IoIcons.IoIosPaper />,\r\n    cName: 'nav-text'\r\n  }\r\n];","import React, { useState } from 'react';\r\nimport * as FaIcons from 'react-icons/fa';\r\nimport * as AiIcons from 'react-icons/ai';\r\nimport { Link } from 'react-router-dom';\r\nimport { SidebarData } from './siderbardata';\r\nimport './siderbar.css';\r\nimport { IconContext } from 'react-icons';\r\n\r\nfunction Navbar() {\r\n  const [sidebar, setSidebar] = useState(true);\r\n\r\n  const showSidebar = () => setSidebar(!sidebar);\r\n\r\n  return (\r\n    <>\r\n      <IconContext.Provider value={{ color: '#fff' }}>\r\n        {/* <div className='navbar'>\r\n          <Link to='#' className='menu-bars'>\r\n            <FaIcons.FaBars  />\r\n          </Link>\r\n        </div> */}\r\n        <nav className={sidebar ? 'nav-menu active' : 'nav-menu'}>\r\n          <ul className='nav-menu-items'>\r\n            <li className='navbar-toggle'>\r\n              <Link to='#' className='menu-bars'>\r\n                <AiIcons.AiFillBuild />\r\n              </Link>\r\n            </li>\r\n            {SidebarData.map((item, index) => {\r\n              return (\r\n                <li key={index} className={item.cName}>\r\n                  <Link to={item.path}>\r\n                    {item.icon}\r\n                    <span>{item.title}</span>\r\n                  </Link>\r\n                </li>\r\n              );\r\n            })}\r\n          </ul>\r\n        </nav>\r\n      </IconContext.Provider>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Navbar;","import React from 'react';\r\n\r\nimport SortingVisalizer from './SortingVisualizer/SortingVisualizer';\r\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\r\nimport MergeSort from './component/mergePage';\r\nimport QuickSort from './component/QuickSort';\r\nimport SelectionSort from './component/SelectionSort';\r\nimport BubbleSort from './component/BubblePage';\r\nimport Navbar from './component/sidebar';\r\nimport './App.css';\r\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Router>\r\n        <Navbar />\r\n        <Routes>\r\n          <Route path='/' exact element={<SortingVisalizer/>} />          \r\n          <Route path='/BubbleSort' exact element={<BubbleSort/>} />\r\n          <Route path='/QuickSort' exact element={<QuickSort/>} />\r\n          <Route path='/SelectSort' exact element={<SelectionSort/>} />\r\n          <Route path='/MergeSort' exact element={<MergeSort/>} />\r\n\r\n        </Routes>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}