{"ast":null,"code":"//function to handle quicks sort animation on the front end\nexport function getQuickSortAnimation(array) {\n  let animations = [];\n  let auxillaryArray = array.slice();\n  quickSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\n  return animations;\n} //end of getQuickSortAnimation()\n//function to handle the quickSort algorithm:\n\nfunction quickSort(auxillaryArray, startIndex, endIndex, animations) {\n  let pivotIndex; //the index of the pivot element in the array\n  //checking the upper and lower bound of the array\n\n  if (startIndex < endIndex) {\n    //return the index of pivot element in the array\n    pivotIndex = partitionArray(auxillaryArray, startIndex, endIndex, animations); //recursive call to sort the left and right partition of the array\n\n    quickSort(auxillaryArray, startIndex, pivotIndex - 1, animations);\n    quickSort(auxillaryArray, pivotIndex + 1, endIndex, animations);\n  }\n} //end of quick sort()\n//Helper method to partition the the array into left and right elements\n\n\nfunction partitionArray(auxillaryArray, startIndex, endIndex, animations) {\n  let pivot = auxillaryArray[endIndex];\n  let pivotIndex = startIndex;\n\n  for (let i = startIndex; i <= endIndex - 1; i++) {\n    animations.push([i, endIndex]);\n    animations.push([i, endIndex]);\n\n    if (auxillaryArray[i] <= pivot) {\n      //Swap these two heights\n      animations.push([i, auxillaryArray[pivotIndex]]);\n      animations.push([pivotIndex, auxillaryArray[i]]);\n      swap(auxillaryArray, i, pivotIndex);\n      pivotIndex++;\n    } else {\n      animations.push([-1, -1]);\n      animations.push([-1, -1]);\n    }\n\n    animations.push([-1, -1]);\n    animations.push([-1, -1]);\n  }\n\n  animations.push([-1, -1]);\n  animations.push([-1, -1]);\n  animations.push([-1, -1]);\n  animations.push([-1, -1]); //Swap these two heights\n\n  animations.push([pivotIndex, auxillaryArray[endIndex]]);\n  animations.push([endIndex, auxillaryArray[pivotIndex]]);\n  swap(auxillaryArray, pivotIndex, endIndex);\n  return pivotIndex;\n} //end of partiontArray()\n//helper method to swap between two different element in the array\n\n\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\n  let temp = auxillaryArray[firstIndex];\n  auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\n  auxillaryArray[secondIndex] = temp;\n} //end of swap()","map":{"version":3,"sources":["E:/codefield/csc301/visualize_sorter_react/src/sortinalgorithms/QuickSort.js"],"names":["getQuickSortAnimation","array","animations","auxillaryArray","slice","quickSort","length","startIndex","endIndex","pivotIndex","partitionArray","pivot","i","push","swap","firstIndex","secondIndex","temp"],"mappings":"AAAA;AACA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AACzC,MAAIC,UAAU,GAAI,EAAlB;AACA,MAAIC,cAAc,GAAGF,KAAK,CAACG,KAAN,EAArB;AACAC,EAAAA,SAAS,CAACF,cAAD,EAAiB,CAAjB,EAAoBA,cAAc,CAACG,MAAf,GAAwB,CAA5C,EAA+CJ,UAA/C,CAAT;AACA,SAAOA,UAAP;AACH,C,CAAA;AAGD;;AACA,SAASG,SAAT,CAAmBF,cAAnB,EAAmCI,UAAnC,EAA+CC,QAA/C,EAAyDN,UAAzD,EAAqE;AACjE,MAAIO,UAAJ,CADiE,CACjD;AAChB;;AACA,MAAIF,UAAU,GAAGC,QAAjB,EAA2B;AACvB;AACAC,IAAAA,UAAU,GAAGC,cAAc,CAACP,cAAD,EAAiBI,UAAjB,EAA6BC,QAA7B,EAAuCN,UAAvC,CAA3B,CAFuB,CAGvB;;AACAG,IAAAA,SAAS,CAACF,cAAD,EAAiBI,UAAjB,EAA6BE,UAAU,GAAG,CAA1C,EAA6CP,UAA7C,CAAT;AACAG,IAAAA,SAAS,CAACF,cAAD,EAAiBM,UAAU,GAAG,CAA9B,EAAiCD,QAAjC,EAA2CN,UAA3C,CAAT;AACH;AACJ,C,CAAA;AAED;;;AACA,SAASQ,cAAT,CAAwBP,cAAxB,EAAwCI,UAAxC,EAAoDC,QAApD,EAA8DN,UAA9D,EAA0E;AACtE,MAAIS,KAAK,GAAGR,cAAc,CAACK,QAAD,CAA1B;AACA,MAAIC,UAAU,GAAGF,UAAjB;;AACA,OAAK,IAAIK,CAAC,GAAGL,UAAb,EAAyBK,CAAC,IAAIJ,QAAQ,GAAG,CAAzC,EAA4CI,CAAC,EAA7C,EAAiD;AAC7CV,IAAAA,UAAU,CAACW,IAAX,CAAgB,CAACD,CAAD,EAAIJ,QAAJ,CAAhB;AACAN,IAAAA,UAAU,CAACW,IAAX,CAAgB,CAACD,CAAD,EAAIJ,QAAJ,CAAhB;;AACA,QAAIL,cAAc,CAACS,CAAD,CAAd,IAAqBD,KAAzB,EAAgC;AAC5B;AACAT,MAAAA,UAAU,CAACW,IAAX,CAAgB,CAACD,CAAD,EAAIT,cAAc,CAACM,UAAD,CAAlB,CAAhB;AACAP,MAAAA,UAAU,CAACW,IAAX,CAAgB,CAACJ,UAAD,EAAaN,cAAc,CAACS,CAAD,CAA3B,CAAhB;AACAE,MAAAA,IAAI,CAACX,cAAD,EAAiBS,CAAjB,EAAqBH,UAArB,CAAJ;AACAA,MAAAA,UAAU;AACb,KAND,MAOK;AACDP,MAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACAX,MAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACH;;AACDX,IAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACAX,IAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACH;;AACDX,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACAX,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACAX,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB;AACAX,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAhB,EAvBsE,CAwBtE;;AACAX,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAACJ,UAAD,EAAaN,cAAc,CAACK,QAAD,CAA3B,CAAhB;AACAN,EAAAA,UAAU,CAACW,IAAX,CAAgB,CAACL,QAAD,EAAWL,cAAc,CAACM,UAAD,CAAzB,CAAhB;AACAK,EAAAA,IAAI,CAACX,cAAD,EAAiBM,UAAjB,EAA6BD,QAA7B,CAAJ;AACA,SAAOC,UAAP;AACH,C,CAAA;AAED;;;AACA,SAASK,IAAT,CAAcX,cAAd,EAA8BY,UAA9B,EAA0CC,WAA1C,EAAuD;AACnD,MAAIC,IAAI,GAAGd,cAAc,CAACY,UAAD,CAAzB;AACAZ,EAAAA,cAAc,CAACY,UAAD,CAAd,GAA6BZ,cAAc,CAACa,WAAD,CAA3C;AACAb,EAAAA,cAAc,CAACa,WAAD,CAAd,GAA8BC,IAA9B;AACH,C,CAAA","sourcesContent":["//function to handle quicks sort animation on the front end\r\nexport function getQuickSortAnimation(array) {\r\n    let animations  = [];\r\n    let auxillaryArray = array.slice();\r\n    quickSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\r\n    return animations;\r\n}//end of getQuickSortAnimation()\r\n\r\n\r\n//function to handle the quickSort algorithm:\r\nfunction quickSort(auxillaryArray, startIndex, endIndex, animations) {\r\n    let pivotIndex; //the index of the pivot element in the array\r\n    //checking the upper and lower bound of the array\r\n    if (startIndex < endIndex) {\r\n        //return the index of pivot element in the array\r\n        pivotIndex = partitionArray(auxillaryArray, startIndex, endIndex, animations);\r\n        //recursive call to sort the left and right partition of the array\r\n        quickSort(auxillaryArray, startIndex, pivotIndex - 1, animations);\r\n        quickSort(auxillaryArray, pivotIndex + 1, endIndex, animations);\r\n    }\r\n}//end of quick sort()\r\n\r\n//Helper method to partition the the array into left and right elements\r\nfunction partitionArray(auxillaryArray, startIndex, endIndex, animations) {\r\n    let pivot = auxillaryArray[endIndex];\r\n    let pivotIndex = startIndex;\r\n    for (let i = startIndex; i <= endIndex - 1; i++) {\r\n        animations.push([i, endIndex]);\r\n        animations.push([i, endIndex]);\r\n        if (auxillaryArray[i] <= pivot) {\r\n            //Swap these two heights\r\n            animations.push([i, auxillaryArray[pivotIndex]]);\r\n            animations.push([pivotIndex, auxillaryArray[i]]);\r\n            swap(auxillaryArray, i , pivotIndex);\r\n            pivotIndex++;\r\n        }\r\n        else {\r\n            animations.push([-1, -1]);\r\n            animations.push([-1, -1]);\r\n        }\r\n        animations.push([-1, -1]);\r\n        animations.push([-1, -1]);\r\n    }\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    animations.push([-1, -1]);\r\n    //Swap these two heights\r\n    animations.push([pivotIndex, auxillaryArray[endIndex]]);\r\n    animations.push([endIndex, auxillaryArray[pivotIndex]]);\r\n    swap(auxillaryArray, pivotIndex, endIndex);\r\n    return pivotIndex;\r\n}//end of partiontArray()\r\n\r\n//helper method to swap between two different element in the array\r\nfunction swap(auxillaryArray, firstIndex, secondIndex) {\r\n    let temp = auxillaryArray[firstIndex];\r\n    auxillaryArray[firstIndex] = auxillaryArray[secondIndex];\r\n    auxillaryArray[secondIndex] = temp;\r\n}//end of swap()\r\n\r\n"]},"metadata":{},"sourceType":"module"}